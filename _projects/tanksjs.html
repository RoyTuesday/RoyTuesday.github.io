---
permalink: /projects/tanks-js
---
<!DOCTYPE html><html><head><title>Tanks</title><meta charset="utf-8" name="viewport" content="width=device-width initial-scale=1"/><style type="text/css">body{background:#742;text-align:center;padding:0;margin:0;}.hide{position:absolute !important;padding:0 !important;margin:-1px !important;width:1px !important;height:1px !important;left:0 !important;top:0 !important;right:0 !important;bottom:0 !important;clip:rect(0 0 0 0);overflow:hidden;}.debug{position:absolute;border:1px solid red;right:0;top:0;}#canvas-wrapper{margin:0 auto;height:100vh;}#canvas{background:#000;width:800px;height:640px;}#canvas table{background:#000;color:#FFF;font:bold 1em/1.2em Helvetica;letter-spacing:1px;border-collapse:collapse;margin:16px auto;}#canvas caption,#canvas th,#canvas td{background:#000;border:1px solid #FFF;padding:1em;}#canvas td{padding:0.5em 1em;}.controls{color:#FFF;font-family:Courier, monospace;text-align:left;text-shadow:1px -2px 1px black, -1px 1px 1px #AAA;padding:0 24px;width:360px;}input[type="checkbox"]{display:none;}input[type="checkbox"] + label{cursor:pointer;display:block;font-size:24px;padding-left:26px;position:relative;margin:0 0 64px;}input[type="checkbox"] + label:before{background:#333;border:2px solid #FFF;border-radius:100%;box-sizing:border-box;content:'';height:18px;left:0;position:absolute;top:2px;width:18px;}input[type="checkbox"] + label:after{background:radial-gradient(circle at center, #F51 25%, #333 100%);border-radius:100%;content:'';height:10px;left:4px;position:absolute;top:6px;transition:transform 200ms;transform:scale(0);width:10px;}input[type="checkbox"]:checked + label:after{transform:scale(1);}.row{font-size:20px;margin:8px auto;text-align:right;width:144px;}.column-2{display:inline-block;padding:0 8px;}</style></head><body><noscript>Please enable JavaScript to play this game</noscript><table id="canvas-wrapper"><tbody><tr><td><canvas id="canvas" width="800" height="640"><table><caption>Sorry, your browser does not meet the minimum requirements for this game</caption><thead><tr><th>Browser</th><th>Oldest Supported Version</th></tr></thead><tbody><tr><td>Internet Explorer</td><td>9.0</td></tr><tr><td>Firefox</td><td>3.6</td></tr><tr><td>Chrome</td><td>4.0</td></tr><tr><td>Safari</td><td>4.0</td></tr><tr><td>Opera</td><td>10.1</td></tr></tbody></table></canvas></td><td class="controls"><input type="checkbox" name="mute" id="mute" checked><label for="mute">Mute Sounds</label><h1>Player 1: <span id="player-1-color"></span></h1><div class="row"><div class="column-2">Forward:</div><div class="column-2">&uarr;</div></div><div class="row"><div class="column-2">Left:</div><div class="column-2">&larr;</div></div><div class="row"><div class="column-2">Right:</div><div class="column-2">&rarr;</div></div><div class="row"><div class="column-2">Fire:</div><div class="column-2">&darr;</div></div><h1>Player 2: <span id="player-2-color"></span></h1><div class="row"><div class="column-2">Forward:</div><div class="column-2">W</div></div><div class="row"><div class="column-2">Left:</div><div class="column-2">A</div></div><div class="row"><div class="column-2">Right:</div><div class="column-2">D</div></div><div class="row"><div class="column-2">Fire:</div><div class="column-2">S</div></div></td></tr></tbody></table><canvas id="prerender" class="hide" width="800" height="640"></canvas></body>
<script type="text/javascript">
  // TODOS
  // - Fix shell collision bug (Think it's fixed!)
  // - AI? 1 vs 1, 2 vs 2?

  /*
    0: Dirt
    1: Grass
    2: Water (Slows movement)
    3: Wall
  */
  const LEVELS = [
    [
      0,0,0,1,1,1,1,1,3,0,0,0,2,2,0,1,1,1,1,1,
      0,0,0,1,1,1,1,1,3,0,0,0,2,2,0,1,3,3,3,3,
      0,0,0,1,1,1,1,1,3,0,0,0,2,2,0,1,0,1,1,1,
      0,0,0,0,1,1,1,1,1,0,0,0,2,2,0,1,3,0,1,1,
      0,0,0,0,0,1,1,1,1,0,0,0,2,2,0,1,3,0,1,1,
      0,0,0,0,0,0,0,1,1,0,0,0,2,2,0,1,3,1,1,1,
      0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,1,3,1,1,1,
      1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,1,3,1,1,1,
      1,1,1,1,1,1,0,0,0,0,2,2,2,0,0,1,1,1,1,1,
      3,3,3,3,3,3,0,0,0,2,2,2,0,0,1,0,1,1,1,1,
      0,0,0,0,0,0,0,0,0,2,2,0,0,1,1,1,0,1,1,1,
      0,0,0,0,0,0,0,0,0,2,2,0,1,1,3,3,3,1,1,1,
      0,0,0,0,0,0,0,0,0,2,2,0,1,1,0,1,1,1,1,1,
      0,0,0,0,0,3,0,0,2,2,0,0,1,1,0,1,1,1,1,1,
      0,0,0,0,1,3,0,0,2,2,0,1,1,1,3,0,1,1,1,1,
      0,0,0,1,1,3,0,0,2,2,0,1,1,1,3,0,1,1,1,1,
      0,0,0,1,1,3,3,2,2,3,3,3,1,1,3,1,1,1,0,1,
      0,0,1,1,0,0,0,2,2,0,0,0,1,1,3,1,1,1,0,1,
      0,0,1,1,0,0,0,2,2,0,0,0,1,1,1,1,1,1,1,1,
      0,0,1,1,0,0,0,2,2,0,0,1,1,1,1,1,1,1,1,1
    ],
    [
      0,0,0,1,1,1,0,0,0,1,1,2,2,2,2,2,2,2,2,2,
      0,0,1,1,1,1,1,0,0,1,1,2,2,2,2,2,2,2,2,2,
      0,1,1,1,1,1,0,0,0,1,1,1,2,2,2,2,2,2,2,2,
      1,1,1,1,1,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,
      1,1,1,1,1,1,0,0,0,0,1,1,1,2,2,2,2,2,2,2,
      1,1,1,1,1,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,
      0,0,1,1,0,0,0,0,0,0,0,1,1,1,2,2,2,2,2,2,
      0,0,0,0,0,0,0,0,3,0,0,0,1,1,1,1,2,2,2,2,
      0,0,0,0,0,0,0,0,3,0,0,0,0,0,1,1,1,1,1,2,
      0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1,1,1,1,
      0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,1,
      1,1,1,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,
      1,1,1,1,1,1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,
      2,2,1,1,1,1,1,1,0,0,0,0,3,0,0,0,0,0,0,0,
      2,2,2,2,2,1,1,1,1,0,0,0,3,0,0,0,1,1,1,0,
      2,2,2,2,2,2,1,1,1,0,0,0,3,0,0,1,0,1,1,1,
      2,2,2,2,2,2,2,1,1,1,0,0,3,0,0,1,1,1,1,1,
      2,2,2,2,2,2,2,1,1,1,0,0,0,0,1,1,1,1,1,0,
      2,2,2,2,2,2,2,2,1,1,0,0,0,0,1,1,1,1,1,0,
      2,2,2,2,2,2,2,2,1,1,1,0,0,0,1,1,1,1,0,0
    ],
    [
      0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
      0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
      0,0,0,1,1,1,1,1,1,1,1,1,1,1,3,3,1,0,0,0,
      0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
      0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,3,3,0,0,
      0,1,1,1,0,0,2,2,0,0,3,1,1,1,1,1,1,3,0,0,
      1,1,1,0,0,2,2,2,2,2,3,3,3,3,1,1,1,3,1,0,
      1,1,0,0,0,2,2,2,2,2,2,2,2,3,1,1,1,3,1,1,
      1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,3,1,1,
      0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
      0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,
      0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,
      0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,1,1,1,
      0,0,3,3,0,0,3,3,3,3,2,2,2,0,0,0,0,1,1,1,
      0,0,0,3,0,0,1,1,1,3,0,0,0,0,0,0,0,1,1,1,
      0,0,0,3,0,0,0,0,1,3,0,0,0,0,0,0,0,1,1,1,
      0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
      1,1,1,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
      1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
      1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1
    ]
  ];
  const RANDOM = LEVELS.length;
  var level = LEVELS[0];
  var levelOption = 0;

  window.debug = 0;

  var round = 1;
  var roundLimit = 5;
  var menu = { show: 1, delay: 0, showLeft: 1, showRight: 1 };
  var final = 0;
  var optionRow = 0;
  const PALETTE = [ '#951', '#791', '#158', '#722' ];
  const paletteNames = [
    'Blue/Green',
    'Red/Yellow',
    'Green/Blue',
    'Yellow/Red'
  ];
  var paletteOption = 0;
  const playerColors = [
    [ '#0AF', '#0D2' ],
    [ '#E04', '#DE2' ],
    [ '#0D2', '#0AF' ],
    [ '#DE2', '#E04' ]
  ];

  var score = [ 0, 0 ];
  var gKeys = [ {},{} ];
  var players = [
    { x:  64, y:  64, r:    0, life: 60, delay: 0 },
    { x: 576, y: 576, r: 3.14, life: 60, delay: 0 }
  ];
  var cpu = { x: 576, y: 64, r: 0, life: 60, delay: 0 };

  function renderTank(context, tank, color) {
    context.fillStyle = color;
    context.beginPath();
    context.moveTo(tank.x + 18 * Math.cos(tank.r + 0.17), tank.y + 18 * Math.sin(tank.r + 0.17));
    context.lineTo(tank.x +  9 * Math.cos(tank.r + 0.34), tank.y +  9 * Math.sin(tank.r + 0.34));
    context.lineTo(tank.x + 12 * Math.cos(tank.r + 1), tank.y + 12 * Math.sin(tank.r + 1));
    context.lineTo(tank.x - 14 * Math.cos(tank.r - 0.79), tank.y - 14 * Math.sin(tank.r - 0.79));
    context.lineTo(tank.x - 14 * Math.cos(tank.r + 0.79), tank.y - 14 * Math.sin(tank.r + 0.79));
    context.lineTo(tank.x + 12 * Math.cos(tank.r - 1), tank.y + 12 * Math.sin(tank.r - 1));
    context.lineTo(tank.x +  9 * Math.cos(tank.r - 0.34), tank.y +  9 * Math.sin(tank.r - 0.34));
    context.lineTo(tank.x + 18 * Math.cos(tank.r - 0.17), tank.y + 18 * Math.sin(tank.r - 0.17));
    context.closePath();
    context.fill();
  }
  function renderLevelPreview(prerender, level) {
    if (level) {
      for (let i = 0; i < 400; i++) {
        prerender.fillStyle = PALETTE[level[i]];
        prerender.fillRect(520 + 4 * (i % 20), 450 + 4 * (i / 20 >> 0), 4, 4);
      }
    }
    else {
      prerender.strokeRect(520, 450, 80, 80);
      prerender.fillText('?', 560, 504);
    }
  }

  function updateRoundLimit(prerender, roundLimit) {
    prerender.fillStyle = '#FFF';
    prerender.font = '48px Courier';
    prerender.clearRect(416, 46, 288, 36);
    prerender.fillText(roundLimit, 560, 80);
  }
  function updatePlayerColors(prerender, option) {
    let splitNames = paletteNames[option].split('/');
    let playerOne = document.getElementById('player-1-color');
    let playerTwo = document.getElementById('player-2-color');

    playerOne.innerHTML = splitNames[0];
    playerOne.style.color = playerColors[option][0];
    playerTwo.innerHTML = splitNames[1];
    playerTwo.style.color = playerColors[option][1];

    prerender.fillStyle = '#FFF';
    prerender.font = '48px Courier';
    prerender.clearRect(416, 206, 288, 40);
    prerender.fillText(paletteNames[option], 560, 240);

    renderTank(prerender, { x: 300, y: 470, r: 0 }, playerColors[option][0]);
    renderTank(prerender, { x: 340, y: 510, r: 3.14 }, playerColors[option][1]);
  }
  function updateLevelOption(prerender, levelOption) {
    prerender.fillStyle = '#FFF';
    prerender.font = '48px Courier';
    prerender.clearRect(416, 366, 288, 36);
    prerender.fillText(levelOption == RANDOM ? 'random' : (levelOption + 1), 560, 400);

    let level = LEVELS[levelOption];
    prerender.clearRect(518, 448, 84, 84);
    renderLevelPreview(prerender, level);
  }

  function prerenderMenu(prerender, roundLimit, option, levelOption) {
    let levelName = levelOption == RANDOM ? 'random' : (levelOption + 1);
    let level = LEVELS[levelOption];

    prerender.clearRect(0, 0, 800, 640);

    prerender.font = '48px Courier';
    prerender.textAlign = 'right';
    prerender.fillStyle = '#FFF';
    prerender.fillText('Rounds:', 320, 80);
    prerender.fillText('Colors:', 320, 240);
    prerender.fillText('Level:', 320, 400);

    prerender.textAlign = 'center';
    prerender.fillText(roundLimit, 560, 80);
    prerender.fillText(paletteNames[option], 560, 240);
    prerender.fillText(levelName, 560, 400);

    prerender.font = '32px Courier';
    prerender.fillText('Press spacebar to start', 400, 584);

    renderTank(prerender, { x: 300, y: 470, r: 0 }, playerColors[option][0]);
    renderTank(prerender, { x: 340, y: 510, r: 3.14 }, playerColors[option][1]);

    renderLevelPreview(prerender, level);
  }

  function updateScore(prerender, score) {
    prerender.clearRect(672, 260, 16, 24);
    prerender.clearRect(672, 364, 16, 24);

    prerender.textAlign = 'left';
    prerender.fillText(score[0], 672, 280);
    prerender.fillText(score[1], 672, 384);
  }

  function updateRound(prerender, round) {
    prerender.clearRect(770, 12, 16, 24);

    prerender.textAlign = 'right';
    prerender.fillText(round, 784, 32);
  }

  function prerenderLevel(prerender, level, levelOption, score, round, roundLimit) {
    prerender.clearRect(0, 0, 800, 640);

    for (let i = 0; i < 400; i++) {
      prerender.fillStyle = PALETTE[level[i]];
      prerender.fillRect(32 * (i % 20), 32 * (i / 20 >> 0), 32, 32);
    }

    prerender.font = '24px Courier New';
    prerender.fillStyle = '#FFF';
    prerender.textAlign = 'left';
    prerender.fillText('Round', 656, 32);
    prerender.fillText('of', 672, 64);
    prerender.fillText('Level', 656, 128);
    prerender.fillText(levelOption == RANDOM ? 'random' : levelOption, 672, 160);
    prerender.fillText('Player 1', 656, 248);
    prerender.fillText(score[0], 672, 280);
    prerender.fillText('Player 2', 656, 352);
    prerender.fillText(score[1], 672, 384);
    prerender.textAlign = 'right';
    prerender.fillText(round, 784, 32);
    prerender.fillText(roundLimit, 784, 64);
  }

  function prerenderFinal(prerender, roundLimit, score) {
    prerender.clearRect(0, 0, 800, 640);

    prerender.fillStyle = '#FFF';
    prerender.font = '72px Courier';
    prerender.textAlign = 'center';
    prerender.fillText('Final Score', 400, 96);

    prerender.font = '32px Courier';
    prerender.fillText('Press spacebar for new game', 400, 584);

    prerender.font = '48px Courier';
    prerender.textAlign = 'right';
    prerender.fillText(roundLimit, 368, 176);
    prerender.fillText('Player 1:', 464, 352);
    prerender.fillText('Player 2:', 464, 448);

    prerender.textAlign = 'left';
    prerender.fillText(roundLimit > 1 ? 'Rounds' : 'Round', 384, 176);
    prerender.fillText(score[0], 496, 352);
    prerender.fillText(score[1], 496, 448);
  }

  var shells = [];
  var Shell = function(p, n) {
    this.x = p.x + 18 * Math.cos(p.r);
    this.y = p.y + 18 * Math.sin(p.r);
    this.r = p.r;
    this.n = n;
    return this;
  };
  Shell.prototype.life = 128;

  var audio;
  if (typeof AudioContext !== 'undefined') { audio = new AudioContext }
  else if (webkitAudioContext) { audio = new webkitAudioContext }
  else { console.error('AudioContext not available') }

  if (audio) {
    audio.mute = 1;
    function toggleMute() {
      audio.mute = document.getElementById('mute').checked;
      if (!audio.mute) {
        playTone(0, 0.1);
      }
    }
    document.getElementById('mute').addEventListener('change', toggleMute);
    toggleMute();
  }

  function hkd(e) {
    if (!e.altKey && !e.ctrlKey && !e.metaKey) {e.preventDefault()}
    if (!e.repeat) {
      if (e.key == '`') { debug = !debug }
      if (final) {
        menu.start = 1;
      }
      else if (menu.show) {
        switch (e.key) {
          case 'ArrowLeft'  : menu.left   = 1; break;
          case 'ArrowRight' : menu.right  = 1; break;
          case 'ArrowUp'    : menu.up     = 1; break;
          case 'ArrowDown'  : menu.down   = 1; break;
          case ' '          : menu.start  = 1; break;
        }
      }
      else {
        switch (e.key) {
          case '`': debug = !debug; break;
          // Player 1
          case 'ArrowLeft'  : gKeys[0].left   = 1; break;
          case 'ArrowRight' : gKeys[0].right  = 1; break;
          case 'ArrowUp'    : gKeys[0].up     = 1; break;
          case 'ArrowDown'  : gKeys[0].fire   = 1; break;
          // Player 2
          case 'a'          : gKeys[1].left   = 1; break;
          case 'd'          : gKeys[1].right  = 1; break;
          case 'w'          : gKeys[1].up     = 1; break;
          case 's'          : gKeys[1].fire   = 1; break;
        }
      }
    }
  }
  function hku(e) {
    if (menu.show) {
      switch (e.key) {
        case 'ArrowLeft'  : menu.left   = 0; break;
        case 'ArrowRight' : menu.right  = 0; break;
        case 'ArrowUp'    : menu.up     = 0; break;
        case 'ArrowDown'  : menu.down   = 0; break;
        case ' '          : menu.start  = 0; break;
      }
    }
    else {
      switch (e.key) {
        // Player 1
        case 'ArrowLeft'  : gKeys[0].left   = 0; break;
        case 'ArrowRight' : gKeys[0].right  = 0; break;
        case 'ArrowUp'    : gKeys[0].up     = 0; break;
        case 'ArrowDown'  : gKeys[0].fire   = 0; break;
        // Player 2
        case 'a'          : gKeys[1].left   = 0; break;
        case 'd'          : gKeys[1].right  = 0; break;
        case 'w'          : gKeys[1].up     = 0; break;
        case 's'          : gKeys[1].fire   = 0; break;
      }
    }
  }

  document.addEventListener('keydown', hkd);
  document.addEventListener('keyup',   hku);

  function calculateGain(f, type, sustain) {
    var gainMod;
    switch (type) {
      case 'sine':      gainMod = sustain ?  4 : 2; break;
      case 'triangle':  gainMod = sustain ?  5 : 2; break;
      case 'sawtooth':  gainMod = sustain ? 20 : 5; break;
      case 'square':    gainMod = sustain ? 22 : 6; break;
    }
    return Math.pow(1.05, f / -20) / gainMod;
  }

  function stopSound(o, g) {
    // In case browser doesn't support WebAudio API
    // or sounds are muted
    if (!audio || audio.mute) { return null }
    let t = audio.currentTime;
    g.gain.setValueAtTime(g.gain.value, t);
    g.gain.linearRampToValueAtTime(0, t + 0.3);
    o.stop(t + 0.4);

    return null;
  }

  function startTreadsSound(p) {
    // In case browser doesn't support WebAudio API
    // or sounds are muted
    if (!audio || audio.mute) {
      return { o: 0, g: 0 };
    }
    let t = audio.currentTime;
    var o = audio.createOscillator();
    var g = audio.createGain();
    o.connect(g);
    g.connect(audio.destination);
    let f = p == 0 ? 110 : 74;
    o.frequency.value = f;
    o.type = "triangle";
    let n = calculateGain(f, 'triangle', true);
    g.gain.value = n;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(n, t + 0.1);
    o.start(t);

    return { o: o, g: g };
  }

  function startTurnSound(p) {
    // In case browser doesn't support WebAudio API
    // or sounds are muted
    if (!audio || audio.mute) {
      return { o: 0, g: 0 }
    }
    let t = audio.currentTime;
    var o = audio.createOscillator();
    var g = audio.createGain();
    o.connect(g);
    g.connect(audio.destination);
    let f = p == 0 ? 220 : 148;
    o.frequency.value = f;
    // o.frequency.value = p == 0 ? 165 : 101;
    o.type = "triangle";
    let n = calculateGain(f, 'triangle', true);
    g.gain.value = n;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(n, t + 0.1);
    o.start(t);

    return { o: o, g: g };
  }

  function playTone(s, d, f, w) {
    // In case browser doesn't support WebAudio API
    // or sounds are muted
    if (!audio || audio.mute) { return 0 }
    let t = audio.currentTime + s;
    var o = audio.createOscillator();
    var g = audio.createGain();
    o.connect(g);
    g.connect(audio.destination);
    if (f) { o.frequency.value = f; }
    else { f = o.frequency.value; }
    if (w) { o.type = w; }
    else { w = o.type; }
    let n = calculateGain(f, w);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(n, t + 0.02);
    g.gain.setValueAtTime(n, t + d - 0.02)
    g.gain.linearRampToValueAtTime(0, t + d);
    o.start(t);
    o.stop(t + d);
  }

  function playFireSound(p) {
    // In case browser doesn't support WebAudio API
    // or sounds are muted
    if (!audio || audio.mute) { return 0 }
    let t = audio.currentTime;
    var o = audio.createOscillator();
    var g = audio.createGain();
    o.connect(g);
    g.connect(audio.destination);
    let f = p == 0 ? 55 : 37;
    o.frequency.value = f;
    o.type = "square";
    g.gain.setValueAtTime(calculateGain(f, 'square'), t);
    g.gain.linearRampToValueAtTime(0, t + 0.2);
    o.start(t);
    o.stop(t + 0.2);
  }

  function playRicochetSound(p) {
    // In case browser doesn't support WebAudio API
    // or sounds are muted
    if (!audio || audio.mute) { return 0 }
    let t = audio.currentTime;
    var o = audio.createOscillator();
    var g = audio.createGain();
    o.connect(g);
    g.connect(audio.destination);
    let f = p == 0 ? 220 : 148;
    o.frequency.value = f;
    o.type = "square";
    g.gain.setValueAtTime(calculateGain(f, 'square'), t);
    g.gain.linearRampToValueAtTime(0, t + 0.2);
    o.start(t);
    o.stop(t + 0.2);
  }

  function playExplodeSound(p) {
    // In case browser doesn't support WebAudio API
    // or sounds are muted
    if (!audio || audio.mute) { return 0 }
    var t = audio.currentTime;
    var o = audio.createOscillator();
    var g = audio.createGain();
    o.connect(g);
    g.connect(audio.destination);
    let f = p == 0 ? 220 : 148;
    o.type = "square";
    let n = calculateGain(f, 'square');
    g.gain.setValueAtTime(n, t);
    g.gain.setValueAtTime(n, t + 0.3);
    g.gain.linearRampToValueAtTime(0, t + 0.4);
    o.frequency.setValueAtTime(f, t);
    o.frequency.exponentialRampToValueAtTime(f / 4, t + 0.4);
    o.start(t);
    o.stop(t + 0.4);
  }

  var x = document.getElementById('canvas').getContext('2d');
  x.fillStyle = '#FFF';

  var prerender = document.getElementById('prerender');
  var preContext = prerender.getContext('2d');
  preContext.strokeStyle = '#FFF';
  preContext.lineWidth = 2;

  updateRoundLimit(preContext, roundLimit);
  updatePlayerColors(preContext, paletteOption);
  updateLevelOption(preContext, levelOption);

  prerenderMenu(preContext, roundLimit, paletteOption, levelOption);

  var step = function(t) {
    // Clear canvas
    x.clearRect(0, 0, 800, 640);

    if (final) {
      x.drawImage(prerender, 0, 0);

      if (menu.start) {
        prerenderMenu(preContext, roundLimit, paletteOption, levelOption);
        x.fillStyle = '#FFF';
        final = 0;
        menu.show = 1;
        menu.start = 0;
        score = [ 0, 0 ];
      }
    }
    else if (menu.show) {
      if (menu.delay == 0) {
        if (menu.start) {
          menu.show = 0;
          menu.start = 0;
          if (levelOption == RANDOM) { level = LEVELS[(Math.random() * RANDOM) >> 0] }
          else { level = LEVELS[levelOption] }
          prerenderLevel(preContext, level, levelOption, score, round, roundLimit);
        }
        else {
          if (menu.up && optionRow > 0) {
            optionRow--;
            playTone(0, 0.1, 120, 'triangle');
            playTone(0, 0.1, 180, 'triangle');
          }
          if (menu.down && optionRow < 2) {
            optionRow++;
            playTone(0, 0.1, 120, 'triangle');
            playTone(0, 0.1, 180, 'triangle');
          }

          if (menu.left || menu.right) {
            switch (optionRow) {
              case 0:
                if (menu.left && roundLimit > 1) {
                  updateRoundLimit(preContext, roundLimit -= 2);

                  let bass = 100 * (1 + roundLimit / 15);
                  playTone(0, 0.1, bass, 'triangle');
                  playTone(0, 0.1, 1.33 * bass, 'triangle');
                }
                if (menu.right && roundLimit < 15) {
                  updateRoundLimit(preContext, roundLimit += 2);

                  let bass = 100 * (1 + roundLimit / 15);
                  playTone(0, 0.1, bass, 'triangle');
                  playTone(0, 0.1, 1.33 * bass, 'triangle');
                }
                break;
              case 1:
                if (menu.left && paletteOption > 0) {
                  updatePlayerColors(preContext, --paletteOption);
                  playTone(0, 0.1, 150, 'triangle');
                  playTone(0, 0.1, 200, 'triangle');
                }
                if (menu.right && paletteOption < 3) {
                  updatePlayerColors(preContext, ++paletteOption);
                  playTone(0, 0.1, 150, 'triangle');
                  playTone(0, 0.1, 200, 'triangle');
                }
                break;
              case 2:
                if (menu.left && levelOption > 0) {
                  updateLevelOption(preContext, --levelOption);
                  playTone(0, 0.1, 150, 'triangle');
                  playTone(0, 0.1, 200, 'triangle');
                }
                if (menu.right && levelOption < RANDOM) {
                  updateLevelOption(preContext, ++levelOption);
                  playTone(0, 0.1, 150, 'triangle');
                  playTone(0, 0.1, 200, 'triangle');
                }
                break;
            }
          }

          if (menu.up || menu.down || menu.left || menu.right) {
            switch (optionRow) {
              case 0:
                if (roundLimit == 1) {
                  if (menu.showLeft) menu.showLeft = 0;
                }
                else if (!menu.showLeft) {
                  menu.showLeft = 1;
                }
                if (roundLimit == 15) {
                  if (menu.showRight) menu.showRight = 0;
                }
                else if (!menu.showRight) {
                  menu.showRight = 1;
                }
                break;
              case 1:
                if (paletteOption == 0) {
                  if (menu.showLeft) menu.showLeft = 0;
                }
                else if (!menu.showLeft) {
                  menu.showLeft = 1;
                }
                if (paletteOption == 3) {
                  if (menu.showRight) menu.showRight = 0;
                }
                else if (!menu.showRight) {
                  menu.showRight = 1;
                }
                break;
              case 2:
                if (levelOption == 0) {
                  if (menu.showLeft) menu.showLeft = 0;
                }
                else if (!menu.showLeft) {
                  menu.showLeft = 1;
                }
                if (levelOption == RANDOM) {
                  if (menu.showRight) menu.showRight = 0;
                }
                else if (!menu.showRight) {
                  menu.showRight = 1;
                }
                break;
            }
            menu.delay = 20;
          }
        }
      }
      // # Render
      x.drawImage(prerender, 0, 0);

      // Option arrows
      var rowY = 65 + 160 * optionRow;
      // Left
      if (menu.showLeft) {
        x.beginPath();
        x.moveTo(360, rowY);
        x.lineTo(400, rowY - 30);
        x.lineTo(400, rowY + 30);
        x.closePath();
        x.fill();
      }
      // Right
      if (menu.showRight) {
        x.beginPath();
        x.moveTo(760, rowY);
        x.lineTo(720, rowY - 30);
        x.lineTo(720, rowY + 30);
        x.closePath();
        x.fill();
      }

      if (menu.delay > 0) { menu.delay-- }
    }
    else {
      // # Updating
      for (let i = 0; i < 2; i++) {
        let p = players[i];
        if (p.life < 60) {
          if (p.life > -30){ p.life-- }
          else {
            if (round < roundLimit) {
              updateRound(preContext, ++round);
              shells = [];
              if (levelOption == RANDOM) { level = LEVELS[Math.random() * RANDOM >> 0]; }
              if (players[0].treads) {
                players[0].treads = stopSound(players[0].treads.o, players[0].treads.g);
              }
              if (players[1].treads) {
                players[1].treads = stopSound(players[1].treads.o, players[1].treads.g);
              }
              if (players[0].turn) {
                players[0].turn = stopSound(players[0].turn.o, players[0].turn.g);
              }
              if (players[1].turn) {
                players[1].turn = stopSound(players[1].turn.o, players[1].turn.g);
              }
              players = [
                { x:  64, y:  64, r:  0, life: 60, delay: 0 },
                { x: 576, y: 576, r: 3.14, life: 60, delay: 0 }
              ];
            }
            else {
              prerenderFinal(preContext, roundLimit, score);
              round = 0;
              final = 1;
            }
            break;
          }
        }
        else {
          let cell = level[(p.x / 32 >> 0) + 20 * (p.y / 32 >> 0)];
          if (gKeys[i].left) {
            p.r -= 0.05;
            while (p.r < 0) {
              p.r += 6.28;
            }
            while (p.r > 6.28) {
              p.r -= 6.28;
            }
            if (!players[i].turn) {
              players[i].turn = startTurnSound(i);
            }
          }
          else if (gKeys[i].right) {
            p.r += 0.05;
            while (p.r < 0) {
              p.r += 6.28;
            }
            while (p.r > 6.28) {
              p.r -= 6.28;
            }
            if (!players[i].turn) {
              players[i].turn = startTurnSound(i);
            }
          }
          else if (players[i].turn) {
            players[i].turn = stopSound(players[i].turn.o, players[i].turn.g);
          }
          if (gKeys[i].up) {
            if (!players[i].treads) {
              players[i].treads = startTreadsSound(i);
            }
            let cos = Math.cos(p.r);
            let sin = Math.sin(p.r);
            let speed = cell == 2 ? 1 : 2;
            let xPos = speed * cos + p.x;
            let yPos = speed * sin + p.y;
            let nextCell = level[(((16 * cos + p.x) / 32) >> 0) + 20 * (((16 * sin + p.y) / 32) >> 0)];
            if (xPos < 16) { p.x = 16 }
            else if (xPos > 624) { p.x = 624 }
            else if (nextCell < 3) { p.x = xPos }
            if (yPos < 16) { p.y = 16 }
            else if (yPos > 624) { p.y = 624 }
            else if (nextCell < 3) { p.y = yPos }
          }
          else if (players[i].treads) {
            players[i].treads = stopSound(players[i].treads.o, players[i].treads.g);
          }
          if (gKeys[i].fire && p.delay == 0) {
            p.delay = 60;
            shells.push(new Shell(p, i));
            playFireSound(i);
          }
          if (p.delay > 0) { p.delay-- }
        }
      }

      // # Rendering
      // Level and Score display
      x.drawImage(prerender, 0, 0);

      // Players
      for (let i = 0; i < 2; i++) {
        let p = players[i];
        let colors = playerColors[paletteOption];
        if (p.life == 60) {
          renderTank(x, p, colors[i]);
        }
        else if (p.life > 0) {
          let r = (60 - p.life) / 3 >> 0;
          x.strokeStyle = colors[i];
          x.beginPath();
          x.moveTo(p.x + r / 4, p.y);
          x.arc(p.x, p.y, r / 4, 0, 6.28);
          if (p.life > 5) {
            x.moveTo(p.x + r / 2, p.y);
            x.arc(p.x, p.y, r / 2, 0, 6.28);
          }
          if (p.life > 15) {
            x.moveTo(p.x + r, p.y);
            x.arc(p.x, p.y, r, 0, 6.28);
          }
          x.stroke();
        }
      }

      // CPU tank
      // renderTank(x, cpu, playerColors[(paletteOption + 1) % 4][0]);

      // Shells
      let liveShells = [];
      let r = 0;
      for (let i = 0; i < shells.length; i++) {
        let h = shells[i];
        for (let p = 0; p < 8; p++) {
          let cos = Math.cos(h.r);
          let sin = Math.sin(h.r);
          h.x += cos;
          h.y += sin;
          if (h.x <= 2 || h.x >= 638) {
            h.r = Math.atan2(sin, -cos);
            if (!r) r = 1;
          }
          if (h.y <= 2 || h.y >= 638) {
            h.r = Math.atan2(-sin, cos);
            if (!r) r = 1;
          }
          let c = ((h.x / 32) >> 0) + 20 * ((h.y / 32) >> 0);
          if (level[c] && level[c] == 3) {
            // Calculate distance from edges of tile
            let fromX = 16 - Math.abs(h.x % 32 - 16) >> 0;
            let fromY = 16 - Math.abs(h.y % 32 - 16) >> 0;
            if (fromX == fromY) {
              h.r = Math.atan2(-sin, -cos);
              if (!r) r = 1;
            }
            else if (fromX < fromY) {
              h.r = Math.atan2(sin, -cos);
              if (!r) r = 1;
            }
            else {
              h.r = Math.atan2(-sin, cos);
              if (!r) r = 1;
            }
          }
        }
        if (r) {
          playRicochetSound(h.n)
        }
        h.life--;
        x.fillStyle = '#FFE';
        x.fillRect(h.x - 2, h.y - 2, 4, 4);
      }
      // Detect player collisions after updating shell positions
      for (let i = 0; i < shells.length; i++) {
        let h = shells[i];
        for (let p = 0; p < 2; p++) {
          if (players[p].life == 60 && Math.sqrt(Math.pow(players[p].x - h.x, 2) + Math.pow(players[p].y - h.y, 2)) < 16) {
            if (players[i].treads) {
              players[i].treads = stopSound(players[i].treads.o, players[i].treads.g);
            }
            if (players[i].turn) {
              stopSound(players[i].turn.o, players[i].turn.g)
            }
            playExplodeSound(p);
            players[p].life--;

            // Score of player who didn't get hit goes up
            score[p==0?1:0]++;
            h.life = 0;
            updateScore(preContext, score);
          }
        }
        if (h.life > 0) { liveShells.push(h) }
      }
      shells = liveShells;
    }

    // Debug
    if (debug) {
      x.fillStyle = '#07F';
      for (let r = 0; r < 640; r += 32) { x.fillRect(0, r, 800, 1) }
      for (let c = 0; c < 800; c += 32) { x.fillRect(c, 0, 1, 640) }
      x.font = '16px Courier';
      x.textAlign = 'left';
      x.fillStyle = 'rgba(255,255,255,0.8)';
      x.fillRect(0, 0, 128, 128);
      x.fillStyle = '#000';
      x.fillText('Muted', 16, 16);
      x.fillText(mute ? 'Yes' : 'No', 72, 16);
    }

    // Pause render loop if user leaves tab
    if (!s) { var s = t }
    if (t - s < 2000) { window.requestAnimationFrame(step) }
  };
  window.requestAnimationFrame(step);
</script>
</html>
