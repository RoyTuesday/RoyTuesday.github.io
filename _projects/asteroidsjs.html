---
permalink: /projects/asteroids-js
---
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Asteroids JS</title>
    <script type="text/javascript">
      // Constants and global function declarations
      var MAX_ASTEROIDS = 7;
      var MAX_SPEED = 6;
      var ASTEROID_SPEED = 1;
      var MAX_SPRITES = 1;
      var VALID_KEYS = {
        'ArrowLeft' : 'Left Arrow',
        'ArrowRight': 'Right Arrow',
        'ArrowUp'   : 'Up Arrow',
        'ArrowDown' : 'Down Arrow',
        'PageUp'    : 'Page Up',
        'PageDown'  : 'Page Down',
        ' '         : 'Spacebar'
      }
      var DEFAULT_KEYS = {
        'left': 'ArrowLeft',
        'right': 'ArrowRight',
        'move': 'ArrowUp',
        'fire': ' ',
        'options': 'O'
      }
      var KEYS_BY_CODE = { 8: 'Backspace', 9: 'Tab', 13: 'Enter', 16: 'Shift', 17: 'Control', 18: 'Alt', 32: ' ', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'ArrowLeft', 38: 'ArrowUp', 39: 'ArrowRight', 40: 'ArrowDown', 45: 'Insert', 46: 'Delete', 186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`', 219: '[', 220: '\\', 221: ']', 222: '\'' }
      for (var code in KEYS_BY_CODE) {
        if (KEYS_BY_CODE.hasOwnProperty(code) && ! VALID_KEYS[KEYS_BY_CODE[code]]) {
          VALID_KEYS[KEYS_BY_CODE[code]] = KEYS_BY_CODE[code];
        }
      }
      for (var i = 48; i < 90; i++) {
        var key = String.fromCharCode(i);
        if (! VALID_KEYS[key]) {
          VALID_KEYS[key] = key;
        }
      }

      var KEY_VALUES = {}
      for (var code in VALID_KEYS) {
        if (VALID_KEYS.hasOwnProperty(code)) {
          KEY_VALUES[VALID_KEYS[code]] = code;
        }
      }

      // Class definitions
      var Button = function(x, y, name) {
        this.x = x;
        this.y = y;
        this.w = 80;
        this.h = 30;
        this.name = name;
        this.hover = false;
        this.active = false;
        this.grad;
      }
      Button.prototype.handleMouseDown = function(event) {
        if (this.hover) this.active = true; return this.name;
      }
      Button.prototype.handleMouseUp = function(event) {
        if (this.active) {
          this.active = false;
          return this.name;
        }
      }
      Button.prototype.handleMouseMove = function(event) {
        return this.hover = ! (event.layerX < this.x || event.layerX > this.x + this.w || event.layerY < this.y - (this.h / 2) || event.layerY > this.y + (this.h / 2));
      }
      Button.prototype.render = function(context) {
        if (! this.grad) {
          this.grad = context.createRadialGradient(this.x + (this.w / 2), this.y, 0, this.x + (this.w / 2), this.y, (this.w / 2));
          this.grad.addColorStop(0, 'rgba(220,124,16,1)');
          this.grad.addColorStop(1, 'rgba(220,124,16,0)');
        }
        context.strokeStyle = '#777';
        context.lineWidth = 3;
        context.beginPath();
        switch (this.name) {
          case 'right':
            context.moveTo(this.x, this.y - (this.h / 2));
            context.lineTo(this.x + (this.w * 0.8), this.y - (this.h / 2))
            context.lineTo(this.x + this.w, this.y);
            context.lineTo(this.x + (this.w * 0.8), this.y + (this.h / 2));
            context.lineTo(this.x, this.y + (this.h / 2));
            break;
          case 'left':
            context.moveTo(this.x, this.y);
            context.lineTo(this.x + (this.w * 0.2), this.y + (this.h / 2))
            context.lineTo(this.x + this.w, this.y + (this.h / 2));
            context.lineTo(this.x + this.w, this.y - (this.h / 2));
            context.lineTo(this.x + (this.w * 0.2), this.y - (this.h / 2));
            break;
        }
        context.closePath();
        context.fillStyle = this.active ? '#444' : this.hover ? '#222' : '#000';
        context.fill();
        context.fillStyle = this.grad;
        context.fill();
        context.stroke();
        context.lineWidth = 1;
      }

      var Slider = function(x, y, name, percent) {
        this.x = x;
        this.y = y;
        this.name = name;
        this.pos = 255 * (percent ? Math.min(1, Math.max(0, percent)) : 1);
        return this;
      }
      Slider.prototype.checkActive = function(event) {
        return this.active = ! (event.layerX < this.x - 8 || event.layerX > this.x + 8 || event.layerY < this.y - 4 || event.layerY > this.y + 256 + 20);
      }
      Slider.prototype.updatePos = function(event) {
        this.pos = Math.min(255, Math.max(0, (255 - (event.layerY - this.y - 20))));
      }
      Slider.prototype.render = function(context) {
        context.fillStyle = '#FFF';
        context.textAlign = 'center';
        context.font = '16px Courier, monospace';
        context.fillText(this.name, this.x, this.y);
        context.fillStyle = '#222';
        context.fillRect(this.x - 2, this.y + 20, 4, 256);
        context.fillStyle = '#CCC';
        context.fillRect(this.x - 8, this.y + 16 + (256 - this.pos), 16, 6);
      }

      var Vector = function(rad, mag) {
        this.rad = typeof rad === 'number' ? rad : 0;
        this.mag = typeof mag === 'number' ? mag : 0;
        return this;
      }
      Vector.prototype.add = function(other) {
        var x = (this.mag * Math.cos(this.rad)) + (other.mag * Math.cos(other.rad));
        var y = (this.mag * Math.sin(this.rad)) + (other.mag * Math.sin(other.rad));
        this.rad = Math.atan2(y, x);
        this.mag = Math.min(MAX_SPEED, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
        return this;
      }

      var Actor = function(x, y, vel, dir) {
        this.x = x;
        this.y = y;
        this.vel = vel;
        this.dir = dir ? dir : new Vector(vel.rad, 0);
        return this;
      }
      Actor.prototype.move = moveActor;
      function moveActor() {
        this.x += this.vel.mag * Math.cos(this.vel.rad);
        this.y += this.vel.mag * Math.sin(this.vel.rad);

        if (this.x < 0) this.x = canvas.width;
        else if (this.x > canvas.width) this.x = 0;

        if (this.y < 0) this.y = canvas.height;
        else if (this.y > canvas.height) this.y = 0;
      }

      var Explosion = function(actor, end) {
        this.x = actor.x;
        this.y = actor.y;
        this.frame = 0;
        this.end = end ? end : 8;
        return this;
      }

      // Global Functions
      function saveHiscore(score) {
        window.localStorage.setItem('hiscore', score);
        return score;
      }
      function loadHiscore() {
        var savedScore = window.localStorage.getItem('hiscore');
        return savedScore ? savedScore : 0;
      }

      function preventEverything(event) {
        event.preventDefault();
        event.stopPropagation();
        return false;
      };

      function adaptAddEventListener(el, eventName, handler, options) {
        if (el.addEventListener) {
          el.addEventListener(eventName, handler, options);
        }
        else {
          function callHandler() { handler.call(el); }
          el.attachEvent('on' + eventName, callHandler);
          if (options.once) {
            setTimeout(function() {
              el.detachEvent('on' + eventName, callHandler);
            });
          }
        }
      }

      // Get's key in browsers with event.key and those without
      function getKey(event) {
        if (KEYS_BY_CODE[event.keyCode]) return KEYS_BY_CODE[event.keyCode];
        else if (/^\w$/.test(String.fromCharCode(event.keyCode))) return String.fromCharCode(event.keyCode);
        else if (event.key) return event.key.length === 1 ? event.key.toUpperCase() : event.key;
      }

      function ready(fun) {
        if (document.readyState != 'loading'){
          fun();
        }
        else if (document.addEventListener) {
          document.addEventListener('DOMContentLoaded', fun);
        }
        else {
          document.attachEvent('onreadystatechange', function() {
            if (document.readyState != 'loading')
              fun();
          });
        }
      }
    </script>
    <style media="screen">
      #main {
        background: #226;
        color: #FFF;
        font: 1rem monospace;
        text-align: center;
        position: fixed;
        top: 0;
        left: 0;
        margin: 0;
        padding: 0;
        max-width: 100vw;
        width: 100%;
        max-height: 100vh;
        height: 100%;
        box-sizing: border-box;
      }
      #wrapper {
        width: 1024px;
        height: 600px;
        transform-origin: top left;
      }
      #canvas {
        background: #000;
        display: inline-block;
        margin: 0;
        padding: 0;
        height: 600px;
        width: 800px;
      }
      aside {
        position: relative;
      	display: inline-block;
      	width: 200px;
        height: 576px;
      	padding: 12px;
        vertical-align: top;
      }
      #score-container {
        margin: 0 0 16px 0;
      }
      .score {
        position: relative;
        background: transparent;
        font: 1rem monospace;
        border: none;
        width: 100%;
        text-align: center;
        box-sizing: border-box;
        box-shadow: 0 0 16px 0 rgba(255,255,255,0.5);
        cursor: default;
      }
      .keybind {
        display: block;
        width: 100%;
        margin: 0;
      }
      label {
        display: block;
        text-shadow: -1px -1px 1px #777, 1px 1px 1px black;
      }
      #score-container label,
      #score-container .input-wrapper {
        display: inline-block;
        margin: 0 auto;
        vertical-align: top;
      }
      #score-container label {
        line-height: 29px;
        width: 45%;
        margin-bottom: 10px;
      }
      #score-container .input-wrapper {
        width: 55%;
      }
      .input-wrapper {
        position: relative;
        background: #000;
        width: 100%;
        padding: 4px;
        margin: 6px 0;
        box-sizing: border-box;
        overflow: hidden;
      }
      .input-display {
        position: absolute;
        top: 50%;
        left: 50%;
        margin-top: -0.625rem;
        margin-left: -50%;
        width: 100%;
        background: transparent;
        font: 1rem monospace;
        color: #FFF;
      }
      input {
        position: relative;
        background: transparent;
        font: 1rem monospace;
        border: none;
        width: 100%;
        transition: 230ms;
        text-align: center;
        box-sizing: border-box;
        box-shadow: 0 0 16px 0 rgba(255,255,255,0.5);
        cursor: pointer;
        text-indent: -9999px;
      }
      input[data-key=""] {
        box-shadow: 0 0 16px 0 rgba(255,63,63,0.8);
      }
      #input-container input:hover,
      #input-container input:focus,
      #keybinds-container input:hover,
      #keybinds-container input:focus {
        box-shadow: 0 0 16px 0 #FFF;
      }
      .button {
      	width: 120px;
      	height: 120px;
      	border-radius: 50%;
      	border: 4px solid;
        margin: 54px auto;
        position: relative;
        box-sizing: border-box;
        box-shadow: 2px 1px 0 2px black;
      }
      .button:after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        border: 3px solid;
        width: 85%;
        height: 85%;
        box-sizing: border-box;
      }
      .button:hover:after {
        border-width: 2px;
      }
      .button:active:after {
        border-width: 5px;
      }
      .button.button-red {
        background: radial-gradient(at 16px 16px, red 20%, #F77 80%);
        border-color: #F44;
      }
      .button.button-red:after {
        background: radial-gradient(at 80px 80px, red 20%, #F44 80%);
        border-color: #500;
      }
      .button.button-red:hover:after {
        background: radial-gradient(at 80px 80px, #F22 20%, #F55 80%);
      }
      .button.button-red:active:after {
        background: radial-gradient(at 60px 60px, #C00 20%, #D22 80%);
      }
      .button.button-yellow {
        background: radial-gradient(at 16px 16px, #DD0 20%, #FF7 80%);
        border-color: #FF4;
      }
      .button.button-yellow:after {
        background: radial-gradient(at 80px 80px, #DD0 20%, #FF4 80%);
        border-color: #550;
      }
      .button.button-yellow:hover:after {
        background: radial-gradient(at 80px 80px, #DD2 20%, #FF5 80%);
      }
      .button.button-yellow:active:after {
        background: radial-gradient(at 60px 60px, #CC0 20%, #DD2 80%);
      }
      #toggle-options {
        background: radial-gradient(ellipse at bottom right, #777777 20%, #D7D7D7 80%);
        position: relative;
        height: 38px;
        width: 200px;
        margin-bottom: 12px;
      }
      #toggle-options:after {
        content: 'Options Menu';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 85%;
        height: 75%;
        background: transparent;
        border: 3px solid black;
        color: #111;
        padding: 3px;
        text-shadow: -1px -1px 0 #DDD;
        box-sizing: border-box;
        cursor: pointer;
      }
      #toggle-options:hover:after {
        background: radial-gradient(ellipse at bottom right, #7F7F7F 15%, #DFDFDF 75%);
        border-width: 2px;
        padding-top: 4px;
      }
      #toggle-options:active:after {
        background: radial-gradient(ellipse at bottom right, #707070 30%, #D0D0D0 90%);
        border-width: 4px;
        padding-top: 2px;
      }
      .button,
      .small-screen,
      .orientation {
        display: none;
      }
      @media (max-width: 1024px) {
        .button {
          display: block;
        }
        #keybinds-container {
          display: none;
        }
      }
      @media (orientation: portrait) and (max-width: 480px) {
        #wrapper {
          display: none;
        }
        .orientation {
          display: block;
          color: #EEE;
          margin: 4em 1em;
        }
      }
      @media (orientation: landscape) and (max-width: 420px), (max-height: 310px) {
        #wrapper {
          display: none;
        }
        .small-screen {
          display: block;
          color: #EEE;
          margin: 4em 1em;
        }
      }
    </style>
  </head>
  <body>
    <div id="main">
      <div id="wrapper">
        <canvas id="canvas" width="800" height="600">
          Sorry, your browser does not meet the minimum requirements for this game
        </canvas><aside>
          <div id="score-container">
            <label for="score">Score</label><div class="input-wrapper"><div id="score" class="score">0</div></div>
            <label for="hiscore">Hi score</label><div class="input-wrapper"><div id="hiscore" class="score">0</div></div>
            <label for="lives">Lives</label><div class="input-wrapper"><div id="lives" class="score">3</div></div>
          </div>
          <div id="toggle-options"></div>
          <div id="keybinds-container">
            <div class="keybind">
              <label for="left">Turn Left</label>
              <div class="input-wrapper">
                <div id="left" class="input-display"></div>
                <input type="text" name="left" value="" data-key="">
              </div>
            </div>
            <div class="keybind">
              <label for="right">Turn Right</label>
              <div class="input-wrapper">
                <div id="right" class="input-display"></div>
                <input type="text" name="right" value="" data-key="">
              </div>
            </div>
            <div class="keybind">
              <label for="move">Fire Thrusters</label>
              <div class="input-wrapper">
                <div id="move" class="input-display"></div>
                <input type="text" name="move" value="" data-key="">
              </div>
            </div>
            <div class="keybind">
              <label for="fire">Fire Missile</label>
              <div class="input-wrapper">
                <div id="fire" class="input-display"></div>
                <input type="text" name="fire" value="" data-key="">
              </div>
            </div>
          </div>
          <div id="button-red" class="button button-red"></div>
          <div id="button-yellow" class="button button-yellow"></div>
        </aside>
      </div>
      <div class="small-screen">
        Sorry, your screen is too small to play this game
      </div>
      <div class="orientation">
        Please rotate your device by one quarter turn
      </div>
    </div>

    <script type="text/javascript">
      ready(function() {
        var inputs = {
          'ArrowLeft': 'left',
          'ArrowRight': 'right',
          'ArrowUp': 'move',
          ' ': 'fire'
        }

        var scene = 'title';
        var scores = { score: 0, hiscore: loadHiscore() };
        var explosions = [];
        var asteroids = [];
        var buttonRed = document.getElementById('button-red');
        var buttonYellow = document.getElementById('button-yellow');
        var optionsButton = document.getElementById('toggle-options');
        var keybindsContainer = document.getElementById('keybinds-container');
        var buttons = document.getElementsByClassName('button');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');
        context.textAlign = 'center';
        context.fillStyle = '#FFF';
        context.strokeStyle = '#FFF';
        context.lineWidth = 1;

        var canvasScale = 1;
        adaptAddEventListener(window, 'resize', updateWrapper);
        function updateWrapper() {
          var scale = 1;
          var wrapper = document.getElementById('wrapper');
          if (window.innerWidth / window.innerHeight > 1024 / 600) {
            scale = window.innerHeight / 600;
          }
          else {
            scale = window.innerWidth / 1024;
          }
          canvasScale = Math.min(1, scale);
          wrapper.style.transform = 'scale(' + canvasScale + ')';
        }
        updateWrapper();

        adaptAddEventListener(optionsButton, 'contextmenu', preventEverything);
        adaptAddEventListener(optionsButton, 'touchstart', handleOptionsButton);
        adaptAddEventListener(optionsButton, 'mousedown', handleOptionsButton);
        function handleOptionsButton() {
          optionsMenu.toggle();
        }

        updateScore(true);
        document.getElementById('hiscore').innerHTML = Math.max(scores.hiscore, hiscore.innerHTML);
        function updateScore(reset) {
          if (reset) scores.score = 0;
          else scores.score++;
          document.getElementById('score').innerHTML = scores.score;
        }
        var livesCounter = document.getElementById('lives');
        function updateLivesCounter() {
          livesCounter.innerHTML = player.lives;
        }

        var keybinds = document.querySelectorAll('#keybinds-container input');
        var keybindDisplays = {}
        for (var i = 0; i < keybinds.length; i++) {
          adaptAddEventListener(keybinds[i], 'keydown', updateKeybinds);
          inputs[DEFAULT_KEYS[keybinds[i].name]] = keybinds[i].name;
          keybinds[i].dataset.key = [DEFAULT_KEYS[keybinds[i].name]];
          var display = document.getElementById(keybinds[i].name);
          display.innerHTML = VALID_KEYS[DEFAULT_KEYS[keybinds[i].name]];
          keybindDisplays[keybinds[i].name] = display;
        }
        function updateKeybinds(event) {
          event.preventDefault();
          var newInputs = {}
          var key = getKey(event);

          if (VALID_KEYS[key]) {
            newInputs[key] = event.target.name;
            event.target.dataset.key = key;
            keybindDisplays[event.target.name].innerHTML = VALID_KEYS[key];
          }
          else if (! event.target.dataset.key) {
            newInputs[DEFAULT_KEYS[event.target.name]] = event.target.name;
            event.target.dataset.key = DEFAULT_KEYS[event.target.name];
            keybindDisplays[event.target.name].innerHTML = VALID_KEYS[DEFAULT_KEYS[event.target.name]];
          }

          var others = document.querySelectorAll('#keybinds-container input:not([name="' + event.target.name + '"])');
          for (var i = 0; i < others.length; i++) {
            if (others[i].dataset.key === event.target.dataset.key) {
              others[i].dataset.key = '';
              keybindDisplays[others[i].name].innerHTML = '';
            }
            else {
              newInputs[KEY_VALUES[others[i].dataset.key]] = others[i].name;
              keybindDisplays[others[i].name].innerHTML = VALID_KEYS[others[i].dataset.key] ? VALID_KEYS[others[i].dataset.key] : '';
            }
          }

          inputs = newInputs;
        }

        function boundRads(rads) {
          return (2 * Math.PI + rads) % (2 * Math.PI);
        }

        while (asteroids.length < 3) spawnAsteroid();
        function spawnAsteroid(ast, rad) {
          var x, y, size;
          if (ast && rad) {
            x = ast.x + ((ast.dir.mag + 2) * Math.cos(rad));
            if (x < 0) x += canvas.width;
            else if (x > canvas.width) x -= canvas.width;

            y = ast.y + ((ast.dir.mag + 2) * Math.sin(rad));
            if (y < 0) y += canvas.height;
            else if (y > canvas.height) y -= canvas.height;

            size = ast.dir.mag - 16;
          }
          else {
            size = 16 * (Math.ceil(Math.random() * 3));
            var rad = Math.random() * (Math.PI * 2);
            var perimPoint = Math.random() * ((2 * canvas.width) + (2 * canvas.height));
            if (perimPoint < canvas.width) {
              x = perimPoint;
              y = 0;
            }
            else if (perimPoint < canvas.width + canvas.height) {
              x = canvas.width;
              y = perimPoint - canvas.width;
            }
            else if (perimPoint < (canvas.width * 2) + canvas.height) {
              x = perimPoint - (canvas.width + canvas.height);
              y = canvas.height;
            }
            else {
              x = 0;
              y = perimPoint - ((canvas.width * 2) + canvas.height);
            }
          }
          asteroids.push(new Actor(x, y, new Vector(rad, ASTEROID_SPEED), new Vector(Math.random() * (Math.PI * 2), size)));
        }

        var missile = false;
        var mTimeout = 0;
        var player = {
          x: canvas.width / 2,
          y: canvas.height / 2,
          vel: new Vector(),
          dir: new Vector(),
          lives: 3,
          vul: true,
          enable: true,
          sprite: 0,
          size: 8,
          rot: 0,
          frame: 0,
          move: moveActor,
          setRot: function(dir) {
            if (this.enable) this.rot = dir == 'right' ? Math.min(1, this.rot + 1) : Math.max(-1, this.rot - 1);
          },
          destroy: function() {
            explosions.push(new Explosion(player, 12));
            this.lives--;
            updateLivesCounter();
            if (this.lives === 0) gameOver();
            else {
              this.enable = false;
              this.vul = false;
              this.x = canvas.width / 2,
              this.y = canvas.height / 2,
              this.vel = new Vector();
              this.dir = new Vector();
              setTimeout(function() { this.enable = true; }.bind(this), 800);
              setTimeout(function() { this.vul = true; }.bind(this), 1200);
            }
          },
          render: function(context, x, y) {
            if (this.enable) {
              var x = x ? x : this.x;
              var y = y ? y : this.y;
              context.beginPath();
              switch (this.sprite) {
                case 0:
                  context.moveTo(x + (16 * Math.cos(this.dir.rad)) + 0.5, y + (16 * Math.sin(this.dir.rad)) + 0.5);
                  context.lineTo(x - (16 * Math.cos(this.dir.rad - (Math.PI / 5))) + 0.5, y - (16 * Math.sin(this.dir.rad - (Math.PI / 5))) + 0.5);
                  context.lineTo(x - (8 * Math.cos(this.dir.rad)) + 0.5, y - (8 * Math.sin(this.dir.rad)) + 0.5);
                  context.lineTo(x - (16 * Math.cos(this.dir.rad + (Math.PI / 5))) + 0.5, y - (16 * Math.sin(this.dir.rad + (Math.PI / 5))) + 0.5);
                  break;
                case 1:
                  context.moveTo(x + (8 * Math.cos(this.dir.rad)) + 0.5, y + (8 * Math.sin(this.dir.rad)) + 0.5);
                  context.lineTo(x + (8 * Math.cos(this.dir.rad + 0.2)) + 0.5, y + (8 * Math.sin(this.dir.rad + 0.2)) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad + 0.1)) + 0.5, y + (16 * Math.sin(this.dir.rad + 0.1)) + 0.5);
                  context.lineTo(x + (17 * Math.cos(this.dir.rad + (Math.PI / 8))) + 0.5, y + (17 * Math.sin(this.dir.rad + (Math.PI / 8))) + 0.5);
                  context.lineTo(x + (14 * Math.cos(this.dir.rad + 0.8)) + 0.5, y + (14 * Math.sin(this.dir.rad + 0.8)) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad + 1)) + 0.5, y + (16 * Math.sin(this.dir.rad + 1)) + 0.5);
                  context.lineTo(x + (18 * Math.cos(this.dir.rad + 1)) + 0.5, y + (18 * Math.sin(this.dir.rad + 1)) + 0.5);
                  context.lineTo(x + (21 * Math.cos(this.dir.rad + 1.1)) + 0.5, y + (21 * Math.sin(this.dir.rad + 1.1)) + 0.5);
                  context.lineTo(x + (19 * Math.cos(this.dir.rad + 1.4)) + 0.5, y + (19 * Math.sin(this.dir.rad + 1.4)) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad + (Math.PI / 2))) + 0.5, y + (16 * Math.sin(this.dir.rad + (Math.PI / 2))) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad + (Math.PI * (5 / 8)))) + 0.5, y + (16 * Math.sin(this.dir.rad + (Math.PI * (5 / 8)))) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad + (Math.PI * (3 / 4)))) + 0.5, y + (16 * Math.sin(this.dir.rad + (Math.PI * (3 / 4)))) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad + (Math.PI * (7 / 8)))) + 0.5, y + (16 * Math.sin(this.dir.rad + (Math.PI * (7 / 8)))) + 0.5);
                  context.lineTo(x - (16 * Math.cos(this.dir.rad)) + 0.5, y - (16 * Math.sin(this.dir.rad)) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad - (Math.PI * (7 / 8)))) + 0.5, y + (16 * Math.sin(this.dir.rad - (Math.PI * (7 / 8)))) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad - (Math.PI * (3 / 4)))) + 0.5, y + (16 * Math.sin(this.dir.rad - (Math.PI * (3 / 4)))) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad - (Math.PI * (5 / 8)))) + 0.5, y + (16 * Math.sin(this.dir.rad - (Math.PI * (5 / 8)))) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad - (Math.PI / 2))) + 0.5, y + (16 * Math.sin(this.dir.rad - (Math.PI / 2))) + 0.5);
                  context.lineTo(x + (17 * Math.cos(this.dir.rad - (Math.PI / 8))) + 0.5, y + (17 * Math.sin(this.dir.rad - (Math.PI / 8))) + 0.5);
                  context.lineTo(x + (16 * Math.cos(this.dir.rad - 0.1)) + 0.5, y + (16 * Math.sin(this.dir.rad - 0.1)) + 0.5);
                  context.lineTo(x + (8 * Math.cos(this.dir.rad - 0.2)) + 0.5, y + (8 * Math.sin(this.dir.rad - 0.2)) + 0.5);
                  break;
              }
              context.closePath();
              context.stroke();
              // Render exhaust
              if (this.dir.mag !== 0) {
                var exMod = 24 + (3 * (this.frame < 3 ? this.frame : 6 - this.frame));
                context.beginPath();
                switch (this.sprite) {
                  case 0:
                    context.moveTo(x - (14 * Math.cos(this.dir.rad)) + 0.5, y - (14 * Math.sin(this.dir.rad)) + 0.5);
                    context.lineTo(x - (18 * Math.cos(this.dir.rad - (Math.PI / 8))) + 0.5, y - (18 * Math.sin(this.dir.rad - (Math.PI / 8))) + 0.5);
                    context.lineTo(x - (exMod * Math.cos(this.dir.rad)) + 0.5, y - (exMod * Math.sin(this.dir.rad)) + 0.5);
                    context.lineTo(x - (18 * Math.cos(this.dir.rad + (Math.PI / 8))) + 0.5, y - (18 * Math.sin(this.dir.rad + (Math.PI / 8))) + 0.5);
                    break;
                  case 1:
                    context.moveTo(x - (19 * Math.cos(this.dir.rad)) + 0.5, y - (19 * Math.sin(this.dir.rad)) + 0.5);
                    context.lineTo(x - (19 * Math.cos(this.dir.rad - (Math.PI / 8))) + 0.5, y - (19 * Math.sin(this.dir.rad - (Math.PI / 8))) + 0.5);
                    context.lineTo(x - (19 * Math.cos(this.dir.rad - (Math.PI / 5))) + 0.5, y - (19 * Math.sin(this.dir.rad - (Math.PI / 5))) + 0.5);
                    context.lineTo(x - (exMod * Math.cos(this.dir.rad)) + 0.5, y - (exMod * Math.sin(this.dir.rad)) + 0.5);
                    context.lineTo(x - (19 * Math.cos(this.dir.rad + (Math.PI / 5))) + 0.5, y - (19 * Math.sin(this.dir.rad + (Math.PI / 5))) + 0.5);
                    context.lineTo(x - (19 * Math.cos(this.dir.rad + (Math.PI / 8))) + 0.5, y - (19 * Math.sin(this.dir.rad + (Math.PI / 8))) + 0.5);
                    break;
                }
                context.closePath();
                context.stroke();
              }
            }
          }
        }

        function setPlayer() {
          player.x = canvas.width / 2;
          player.y = canvas.height / 2;
          player.vel = new Vector();
          player.dir = new Vector();
          player.lives = 3;
          player.vul = true;
          player.enable = true;
          player.rot = 0;
          player.frame = 0;
        }
        setPlayer();

        var togX = 580;
        var togY = 500;
        var switchGrad = context.createRadialGradient(togX, togY + (window.innerWidth > 1024 ? -20 : 20), 0, togX, togY + (window.innerWidth > 1024 ? -20 : 20), 8);
        switchGrad.addColorStop(0, '#999');
        switchGrad.addColorStop(1, '#555');
        var lightGrad = context.createRadialGradient(togX + 140, togY + (window.innerWidth > 1024 ? -10 : 10), 0, togX + 140, togY + (window.innerWidth > 1024 ? -10 : 10), 10);
        lightGrad.addColorStop(0, '#E33');
        lightGrad.addColorStop(1, 'rgba(0,0,0,0)');
        var optionsMenu = {
          active: false,
          allowSpriteSwitch: Math.min(MAX_SPRITES, Math.floor(scores.hiscore / 20)) > 0,
          buttons: [new Button(125, 500, 'left'), new Button(400, 500, 'right')],
          sliders: [new Slider(600, 130, 'R'), new Slider(632, 130, 'G'), new Slider(664, 130, 'B')],
          toggleSwitch: {
            x: togX, y: togY, dir: window.innerWidth > 1024 ? -1 : 1,
            grad: switchGrad, light: lightGrad,
            over: function(event) {
              return ! (event.layerX < this.x - 6 || event.layerX > this.x + 6 || event.layerY < this.y - 20 || event.layerY > this.y + 20);
            },
            toggle: function() {
              this.dir *= -1;
              var switchGrad = context.createRadialGradient(this.x, this.y + (this.dir * 20), 0, this.x, this.y + (this.dir * 20), 8);
              switchGrad.addColorStop(0, this.dir < 0 ? '#999' : '#555');
              switchGrad.addColorStop(1, this.dir < 0 ? '#555' : '#999');
              this.grad = switchGrad;
              var lightGrad = context.createRadialGradient(this.x + 140, this.y + (this.dir * 10), 0, this.x + 140, this.y + (this.dir * 10), 10);
              lightGrad.addColorStop(0, '#E33');
              lightGrad.addColorStop(1, 'rgba(0,0,0,0)');
              this.light = lightGrad;
              toggleControls();
            },
            render: function (context) {
              context.fillStyle = '#111';
              context.strokeStyle = '#777';
              context.lineWidth = 3;
              context.beginPath();
              context.moveTo(this.x + 5, this.y);
              context.arc(this.x, this.y, 5, 0, Math.PI * 2);
              context.closePath();
              context.fill();
              context.stroke();
              context.fillStyle = this.grad;
              context.beginPath();
              context.moveTo(this.x + 2, this.y);
              context.arc(this.x, this.y, 2, 0, Math.PI, this.dir === 1);
              context.lineTo(this.x - 4, this.y + (this.dir * 20));
              context.arc(this.x, this.y + (this.dir * 20), 4, Math.PI, Math.PI * 2, this.dir === 1);
              context.lineTo(this.x + 4, this.y + (this.dir * 20));
              context.closePath();
              context.fill();
              context.font = '16px Courier, monospace';
              context.textAlign = 'left';
              context.fillStyle = '#FFF';
              context.fillText('Keyboard', this.x + 20, this.y - 6);
              context.fillText('Touchscreen', this.x + 20, this.y + 16);
              context.fillStyle = this.light;
              context.beginPath();
              context.moveTo(this.x + 160, this.y + (this.dir * 10));
              context.arc(this.x + 140, this.y + (this.dir * 10), 10, 0, Math.PI * 2);
              context.closePath();
              context.fill();
              context.lineWidth = 1;
            }
          },
          toggle: function() {
            this.active = ! this.active;
            this.allowSpriteSwitch = Math.min(MAX_SPRITES, Math.floor(scores.hiscore / 20)) > 0;
          },
          handleMouseDown: function(event) {
            if (this.active) {
              if (this.toggleSwitch.over(event)) {
                this.toggleSwitch.toggle();
                return;
              }
              for (var i = 0; i < this.sliders.length; i++) {
                if (this.sliders[i].checkActive(event)) {
                  this.sliders[i].updatePos(event);
                  break;
                }
              }
              this.buttons.forEach(function(btn) { btn.handleMouseDown(event); });
            }
          },
          handleMouseUp: function(event) {
            this.sliders.forEach(function(slider) { slider.active = false; });
            this.buttons.forEach(function(btn) {
              var max = Math.min(MAX_SPRITES, Math.floor(scores.hiscore / 20));
              switch (btn.handleMouseUp(event)) {
                case 'left': player.sprite--; if (player.sprite < 0) player.sprite = max; break;
                case 'right': player.sprite = (player.sprite + 1) % (max + 1); break;
              }
            });
          },
          handleMouseMove: function(event) {
            if (this.active) {
              for (var i = 0; i < this.sliders.length; i++) {
                if (this.sliders[i].active) {
                  this.sliders[i].updatePos(event);
                  break;
                }
              }
              this.buttons.forEach(function(btn) { btn.handleMouseMove(event); });
            }
          },
          render: function(context) {
            if (this.active) {
              context.fillStyle = 'rgba(0,0,0,0.4)';
              context.fillRect(0, 0, canvas.width, canvas.height);
              context.fillStyle = '#FFF';
              context.font = '32px Courier, monospace';
              context.textAlign = 'left';
              context.fillText('Options', 60, 60);
              this.toggleSwitch.render(context);
              if (this.allowSpriteSwitch) this.buttons.forEach(function(btn) { btn.render(context); });
              this.sliders.forEach(function(slider) { slider.render(context); });
              context.fillStyle = '#000';
              context.strokeStyle = '#777';
              context.fillRect(150, 100, 300, 300);
              context.strokeRect(150, 100, 300, 300);
              // Update the colors based on sliders
              context.strokeStyle = context.fillStyle = 'rgb(' + this.sliders.map(function(slider) { return slider.pos }).join(',') + ')';
              player.render(context, 300, 250);
            }
          }
        }
        function toggleControls() {
          var keyDisp = keybindsContainer.style.display ? keybindsContainer.style.display : getComputedStyle(keybindsContainer).display;
          var buttonDisp = buttons[0].style.display ? buttons[0].style.display : getComputedStyle(buttons[0]).display;

          keybindsContainer.style.display = keyDisp === 'none' ? 'block' : 'none';
          for (var i = 0; i < buttons.length; i++) {
            buttons[i].style.display = buttonDisp === 'none' ? 'block' : 'none';
          }
        }
        // Mouse events
        adaptAddEventListener(canvas, 'mousedown', function(event) { optionsMenu.handleMouseDown(event) });
        adaptAddEventListener(canvas, 'mouseup', function(event) { optionsMenu.handleMouseUp(event) });
        adaptAddEventListener(canvas, 'mousemove', function(event) { optionsMenu.handleMouseMove(event) });

        adaptAddEventListener(canvas, 'contextmenu', preventEverything);
        adaptAddEventListener(buttonRed, 'contextmenu', preventEverything);
        adaptAddEventListener(buttonYellow, 'contextmenu', preventEverything);
        // Touch events
        var touch = { x: 0, y: 0, active: false }
        adaptAddEventListener(canvas, 'touchstart', handleTouchDown);
        adaptAddEventListener(canvas, 'touchmove', handleTouchMove);
        adaptAddEventListener(canvas, 'touchend', handleTouchUp);
        adaptAddEventListener(canvas, 'touchcancel', handleTouchUp);
        // Touch event Handlers
        function handleTouchDown(event) {
          touch.active = true;
          handleTouchMove(event);
        }
        function handleTouchMove(event) {
          touch.x = event.touches[0].clientX * (1 / canvasScale);
          touch.y = event.touches[0].clientY * (1 / canvasScale);
        }
        function handleTouchUp(event) {
          touch.active = false;
          if (player) player.rot = 0;
        }
        // Key Events
        adaptAddEventListener(document, 'keydown', handleKeyDown);
        adaptAddEventListener(document, 'keyup', handleKeyUp);
        // Key event Handlers
        function handleKeyDown(event) {
          var key = getKey(event);
          if (event.target.tagName !== 'INPUT' && ! event.repeat && inputs[key]) {
            event.preventDefault();
            switch (inputs[key]) {
              case 'left': if (player) player.setRot('left'); break;
              case 'right': if (player) player.setRot('right'); break;
              case 'move': updateThrusters(true); break;
              case 'fire': handleFireAction(); break;
            }
          }
        }
        function handleKeyUp(event) {
          var key = getKey(event);
          if (event.target.tagName !== 'INPUT' && ! event.repeat && inputs[key]) {
            event.preventDefault();
            switch (inputs[key]) {
              case 'left': if (player && player.rot !== 0) player.setRot('right'); break;
              case 'right': if (player && player.rot !== 0) player.setRot('left'); break;
              case 'move': updateThrusters(); break;
            }
          }
        }
        // Touch Events
        adaptAddEventListener(buttonRed, 'touchstart', handleFireAction);
        adaptAddEventListener(buttonYellow, 'touchstart', handleYellowButton);
        adaptAddEventListener(buttonYellow, 'touchend', handleYellowButton);
        adaptAddEventListener(buttonYellow, 'touchcancel', handleYellowButton);
        // Touch event Handlers
        function handleFireAction(event) {
          if (scene !== 'game') reset();
          else if (player.enable && ! missile) {
            missile = new Actor(player.x + (12 * Math.cos(player.dir.rad)), player.y + (12 * Math.sin(player.dir.rad)), new Vector(player.dir.rad, MAX_SPEED + 1));
            missile.life = 1000;
          }
        }
        function handleYellowButton(event) {
          event.preventDefault();
          if (player) {
            updateThrusters(event.type === 'touchstart');
          }
        }
        function updateThrusters(fireThrusters) {
          if (! optionsMenu.active && player.enable) {
            player.dir.mag = fireThrusters ? 1 : 0;
          }
        }
        function breakMissile() {
          missile = false;
          clearTimeout(mTimeout);
        }

        function reset() {
          setPlayer();
          updateLivesCounter();
          updateScore(true);
          breakMissile();
          asteroids = [];
          while (asteroids.length < 3) spawnAsteroid();
          scene = 'game';
        }

        var updateInterval = window.setInterval(update, 20);
        function update() {
          if (! optionsMenu.active) {
            if (missile) {
              missile.move();
              missile.life -= 20;
              if (missile.life <= 0) missile = false;
            }
            asteroids.forEach(function(ast) { ast.move() });
            handleCollisions();

            switch (scene) {
              case 'game':
                if (touch.active) {
                  var diff = boundRads(Math.atan2(touch.y - player.y, touch.x - player.x)) - player.dir.rad;
                  if (Math.abs(diff) > Math.PI) player.rot = diff > 0 ? -1 : 1;
                  else if (Math.abs(diff) > 0.1) player.rot = diff > 0 ? 1 : -1;
                  else player.rot = 0;
                }

                player.dir.rad = boundRads(player.dir.rad + (player.rot * (Math.PI / 24)));
                if (player.dir.mag > 0) {
                  player.vel.add(player.dir);
                }
                player.frame = (player.frame + 1) % 6;
                player.move();
                break;
            }
          }
        }
        function handleCollisions() {
          for (var i = 0; i < asteroids.length; i++) {
            if (scene == 'game' && detectActorCollision(player, asteroids[i]) && player.vul) player.destroy();
            else if (missile && detectActorCollision(missile, asteroids[i])) {
              breakMissile();
              if (asteroids[i].dir.mag === 16) updateScore();
              breakAsteroid(i);
              asteroids.splice(i, 1);
            }
            else {
              for (var j = 0; j < asteroids.length; j++) {
                if (i !== j && detectActorCollision(asteroids[i], asteroids[j])) {
                  breakAsteroid(i);
                  breakAsteroid(j);
                  var newAsts = [];
                  asteroids.forEach(function(ast, index) {
                    if (index !== i && index !== j) newAsts.push(ast);
                  });
                  asteroids = newAsts;
                  break;
                }
              }
            }
          }
        }
        function detectActorCollision(actA, actB) {
          return Math.sqrt(Math.pow(Math.abs((actA.x + actA.dir.mag) - actB.x), 2) + Math.pow(Math.abs((actA.y + actA.dir.mag) - actB.y), 2)) < (actB.dir.mag + actA.dir.mag);
        }
        function breakAsteroid(index) {
          switch (asteroids[index].dir.mag) {
            case 48:
              spawnAsteroid(asteroids[index], asteroids[index].vel.rad + (Math.PI / 2));
              spawnAsteroid(asteroids[index], asteroids[index].vel.rad - (Math.PI / 2));
              break;
            case 32:
              spawnAsteroid(asteroids[index], asteroids[index].vel.rad + (Math.PI / 2));
              spawnAsteroid(asteroids[index], asteroids[index].vel.rad - (Math.PI / 2));
              break;
            default:
              explosions.push(new Explosion(asteroids[index]));
              break;
          }
          if (asteroids.length < MAX_ASTEROIDS) setTimeout(spawnAsteroid, 1000);
        }

        function render() {
          context.clearRect(0, 0, canvas.width, canvas.height);
          // Render missile
          if (missile) context.strokeRect(missile.x - 0.5, missile.y - 0.5, 1, 1);
          // Render asteroids
          asteroids.forEach(function(ast) {
            context.beginPath();
            context.moveTo(ast.x + (ast.dir.mag * (Math.cos(ast.dir.rad))), ast.y + (ast.dir.mag * (Math.sin(ast.dir.rad))));
            context.lineTo(ast.x + (ast.dir.mag * (Math.cos(ast.dir.rad - (Math.PI / 4)))), ast.y + (ast.dir.mag * (Math.sin(ast.dir.rad - (Math.PI / 4)))));
            context.lineTo(ast.x + ((ast.dir.mag * 0.8) * (Math.cos(ast.dir.rad - (Math.PI / 3)))), ast.y + ((ast.dir.mag * 0.8) * (Math.sin(ast.dir.rad - (Math.PI / 3)))));
            context.lineTo(ast.x + (ast.dir.mag * (Math.cos(ast.dir.rad - (Math.PI / 2)))), ast.y + (ast.dir.mag * (Math.sin(ast.dir.rad - (Math.PI / 2)))));
            context.lineTo(ast.x + (ast.dir.mag * (Math.cos(ast.dir.rad - (Math.PI * 3 / 4)))), ast.y + (ast.dir.mag * (Math.sin(ast.dir.rad - (Math.PI * 3 / 4)))));
            context.lineTo(ast.x - (ast.dir.mag * (Math.cos(ast.dir.rad))), ast.y - (ast.dir.mag * (Math.sin(ast.dir.rad))));
            context.lineTo(ast.x - (ast.dir.mag * (Math.cos(ast.dir.rad - (Math.PI / 4)))), ast.y - (ast.dir.mag * (Math.sin(ast.dir.rad - (Math.PI / 4)))));
            context.lineTo(ast.x - (ast.dir.mag * (Math.cos(ast.dir.rad - (Math.PI / 2)))), ast.y - (ast.dir.mag * (Math.sin(ast.dir.rad - (Math.PI / 2)))));
            context.lineTo(ast.x - ((ast.dir.mag * 1.1) * (Math.cos(ast.dir.rad - (Math.PI * 5 / 8)))), ast.y - ((ast.dir.mag * 1.1) * (Math.sin(ast.dir.rad - (Math.PI * 5 / 8)))));
            context.lineTo(ast.x - (ast.dir.mag * (Math.cos(ast.dir.rad - (Math.PI * 3 / 4)))), ast.y - (ast.dir.mag * (Math.sin(ast.dir.rad - (Math.PI * 3 / 4)))));
            context.closePath();
            context.stroke();

            // Debug render circle hitbox
            // context.strokeStyle = 'red';
            // context.beginPath();
            // context.moveTo(ast.x + ast.dir.mag, ast.y);
            // context.arc(ast.x, ast.y, ast.dir.mag, 0, Math.PI * 2);
            // context.closePath();
            // context.stroke();
            // context.strokeStyle = 'white';
          });

          switch(scene) {
            case 'title':
              context.textAlign = 'center';
              context.font = '48px Courier, monospace';
              context.fillText('ASTEROIDS JS', canvas.width / 2, (canvas.height / 2) - 32);
              context.font = '18px Courier, monospace';
              context.fillText('Press "fire" to start', canvas.width / 2, (canvas.height / 2) + 8);
              break;
            case 'game':
              context.lineWidth = 1;
              player.render(context);
              break;
            case 'over':
              context.textAlign = 'center';
              context.font = '64px Courier, monospace';
              context.fillText('GAME', canvas.width / 2, (canvas.height / 2) - 32);
              context.fillText('OVER', canvas.width / 2, (canvas.height / 2) + 32);
              break;
          }

          var newExp = [];
          explosions.forEach(function(exp) {
            context.beginPath();
            context.moveTo(exp.x + (exp.frame + 4), exp.y);
            context.arc(exp.x, exp.y, exp.frame + 4, 0, Math.PI * 2);
            context.closePath();
            context.stroke();
            // Increment the explosion's animation frame
            if (! optionsMenu.active) exp.frame++
            if (exp.frame < exp.end) newExp.push(exp);
          });
          explosions = newExp;

          optionsMenu.render(context);
        }

        function gameOver() {
          scene = 'over';
          scores.hiscore = Math.max(scores.score, scores.hiscore);
          document.getElementById('hiscore').innerHTML = scores.hiscore;
        }

        window.requestAnimationFrame(step);
        function step(timestamp) {
          if (! start) var start = timestamp;
          var progress = timestamp - start;

          render();

          if (progress < 2000) {
            window.requestAnimationFrame(step);
          }
        }
      });
    </script>
  </body>
</html>
